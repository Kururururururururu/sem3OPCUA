% set the problem in context.
% summarise what you have done.
% describe your design solution.
% report on its performance.
% provide key recommendations.
\section{Design}
Since the project aims to develop a solution to automate and thereby ease the beer production process for the hobbyists, our design solution is strictly developed based on the previously mentioned personas.
This process can under normal circumstances be a rather complex and very manual process, the user would have to manually control the temperature, add the correct ingredients and the right amount at the right time, while continously monitoring the process to ensure that everything is going according to plan.
The hobbyist might want to produce both produce multiple amounts, but also different kinds of beer. This would require the user to look-up each recipe every time to do the same recipe calculations based on the desired amount and beer type with every new batch, and manually monitor and possible adjust the temperatures of the ingredients throughout the process.
This process can quickly become overwhelming and tedious, and might lead to human errors as the production expands and possibly end up taking the joy out of the hobby.

Our design goal is to make brewing easy and accessible to everyone, even for the least technical of peopple. We want to solve this issue by having a simple and clean user interface, without too much uneccessary information, where all the heavy calculations, continuous monitoring, and processing is done by software behind the scenes.
 
The design aims to deter people from the seemingly advanced process of beer production by offering an intuitive and easy-to-use platform that removes the complexity and makes brewing accessible to everyone.

\subsection{System Architecture}
The architecture of the system is based on the client-server model and include three deployments: The web-service, the database service, and the physical beer machine. 
The Web Service will consist of the front-end, back-end, and the OPC Client. There will be a direct line of communication between the user input in the user interface, through the data processing and handling in the back-end, to the OPC Client that will handle the secure communication and instructions to the physical beer machine.
This deployment model ensures a clear separation of concerns, enabling efficient scaling in the future, while easing the maintenance of individual components.

\subsubsection{Frontend}
The user interface (UI) of the beer production system is developed using React, a powerful and easy-to-use JavaScript library with a lot of flexibility and efficiency in building interactive and dynamic user interfaces, which perfectly aligned with our goal of creating a user-friendly and responsive frontend for the beer production application.

Component-Based Design
React's component-based structure allows for the modular development of UI elements, enhancing code reusability and maintainability. Each aspect of the user interface, such as recipe selection, brewing process initiation, and notifications, will be encapsulated within distinct React components.

Responsive and Intuitive GUI
The React-based front end will prioritize responsiveness, ensuring a seamless user experience across different devices and screen sizes. The GUI will be intuitively designed to provide clear instructions and easy navigation for users, regardless of their level of brewing expertise. React's virtual DOM (Document Object Model) will be leveraged to optimize rendering performance and enhance the overall responsiveness of the interface.

State Management
React's state management capabilities will be utilized to efficiently handle and update the application's state as users interact with the system.

Integration with Back-End
The React front end will seamlessly integrate with the Java-based back end, establishing a robust connection for data exchange between the user interface and the beer production machine. This integration allows for smooth communication, enabling users to interact with the system and receive real-time feedback on the brewing process.

User-Friendly Design Principles
The design principles of the React-based front end will align with the user-friendly goals of the project. Minimal input fields and a streamlined layout will be implemented to simplify the brewing process for users with varying levels of experience.

Testing and Iterative Development
The React front end will undergo rigorous testing to ensure compatibility, responsiveness, and usability. 

In summary, the use of React in the front-end design ensured us a highly adaptable, responsive, and user-friendly interface for the beer production system. The component-based approach and integration capabilities with the backend contributed to the overall success of the project in meeting its requirements.

\subsubsection{Backend}
The back-end component of the beer production system will be implemented using Node.js, a versatile JavaScript runtime known for its efficiency in building scalable and high-performance server-side applications. Leveraging the strengths of Node.js, we aim to create a secure and reliable back-end that seamlessly communicates with the front end and the PLC-controlled beer production machine.

Node.js for Asynchronous Operations
Node.js excels in handling asynchronous operations, making it well-suited for scenarios where real-time communication and responsiveness are crucial. This feature aligns perfectly with the requirements of our beer production system, allowing for efficient communication between the user interface and the hardware components.

RESTful API Development
The back end will expose a RESTful API (Application Programming Interface) to facilitate communication between the front end and the PLC-controlled beer production machine. This API will define endpoints for actions such as initiating the brewing process, retrieving data, and handling alerts or notifications. Node.js, with its lightweight and fast I/O operations, is ideal for developing RESTful APIs.

Secure Communication
Security is paramount in the back-end design. Node.js offers robust libraries and modules for implementing secure communication protocols, such as HTTPS. This ensures that data exchanged between the front end and the beer production machine is encrypted, minimizing the risk of unauthorized access.

Data Storage with NoSQL Database
For efficient data storage and retrieval, a NoSQL database, such as MongoDB, will be employed. Node.js seamlessly integrates with NoSQL databases, offering a flexible and scalable solution for storing data related to beer recipes, production logs, and system configurations.

WebSocket for Real-Time Communication
To enable real-time communication and push notifications to the front end, WebSocket technology will be implemented using Node.js. This bidirectional communication channel ensures that users receive immediate updates on the brewing process, alerts, or any other relevant information.

Containerization for Scalability
In line with the project's emphasis on scalability, containerization technologies like Docker and Kubernetes will be utilized. Node.js applications can be efficiently containerized, providing a scalable and easily deployable solution. This approach ensures that the back-end infrastructure can adapt to increased load or additional features in the future.

Logging and Monitoring
Node.js provides robust logging mechanisms, allowing for the systematic recording of events and errors. Monitoring tools will be integrated to track the performance and health of the back-end system. This ensures that any issues can be promptly identified and addressed.

Testing and Continuous Integration
The Node.js back end will undergo thorough testing to validate its functionality, security, and scalability. Continuous Integration (CI) practices will be implemented to automate the testing process, ensuring that each code change is rigorously assessed for quality and reliability.

In summary, the use of Node.js for back-end development brings scalability, real-time communication, and security to the beer production system. By leveraging the strengths of Node.js, we aim to create a robust foundation that seamlessly integrates with the front end and effectively communicates with the PLC-controlled beer production machine.

\subsubsection{communication}
The communication between the front-end and the back-end is implemented using a RESTful API. 

\subsection{Simulation}
Incorporating the provided ARsim simulation tool early on into our development process was a crucial aspect of this project. 
The early integration allowed us to speed up the development time from the very beginning of the project, as most of our program's functionalities could be tested directly without the need for direct access to the physical machine.
As the tool allowed us to interact with ARsim in a manner similar to how our software would communicate with the actual hardware, it also enabled multiple people to test multiple different things without interfering with one another.
% ARsim serves as a valuable resource that enables simulation of the beer production process without the need for direct access to the physical machine. 
%This simulation tool will be instrumental in testing and refining our software application.

\subsubsection{ARsim Integration}
The ARsim simulation tool was integrated early into the development process, to mimic the behavior of the beer machine.
The early integration allowed us to speed up the development time from the very beginning of the project, as most of our program's functionalities could be tested directly without the need of the physical beer machine.
This integration also allowed us to interact with ARsim in a manner similar to how our software would communicate with the actual hardware, and enabled multiple people to test multiple different things without interfering with one another. 
% By leveraging ARsim, we can perform comprehensive testing of the software's functionalities, ensuring robustness and reliability.

\subsubsection{Testing Scenarios}


\subsection{Data Processing and Logging}

\subsection{Security Measures}

\subsection{Prioritization of Requirements}

\subsection*{Development Methodology}

\subsection*{Risk and Mitigation}

\subsection{Project Organization}

\subsection{Deliverables}